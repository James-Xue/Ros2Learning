# 🧶 深度解析：可重入组 (Reentrant Callback Group)

## 🎯 核心问题

> **什么是可重入组？为什么要叫这个名字？该如何理解？**

---

## 1. 什么是 "可重入" (Reentrancy)？

在计算机科学中，**可重入 (Reentrant)** 是一个经典概念。

### 核心定义
如果一个函数可以被 **“中途打断，然后再次进入”** 执行，而不会导致数据破坏或崩溃，那么它就是可重入的。

### 生活类比：收银员
- **不可重入 (Mutually Exclusive)**：一个收银员只能同时给一个顾客结账。在结账完成前，第二个顾客必须等。
- **可重入 (Reentrant)**：收银员正在给 A 结账，突然主管叫他处理一个紧急退款（另一个任务）。他记下 A 的进度，处理完退款，再回来继续给 A 结账。这要求收银员能记住多个任务的状态。

---

## 2. ROS 2 中的“可重入”意味着什么？

在 ROS 2 的回调组语境下，“可重入”意味着：**打破了排队规则。**

### 并发规则对比

| 特性 | **MutuallyExclusive** (互斥) | **Reentrant** (可重入) |
|---|---|---|
| **基本逻辑** | 只要有一个人在跑，其他人全等着。 | 只要有空闲线程，谁都可以跑。 |
| **自重入性** | **同一个**定时器还没跑完，下次触发时必须排队。 | **同一个**定时器还没跑完，下次触发时**直接开新线程**跑。 |
| **线程安全** | 框架帮你保证了互斥（单线程视觉）。 | **你自己**必须保证代码是线程安全的。 |

---

## 3. 为什么叫“可重入”？（深入理解）

这个名字非常准确地描述了其行为：**“函数还没退出，就再次进入执行。”**

### 场景：耗时 2 秒的定时器，周期 1 秒

设想你设置了一个 `1Hz` (1秒) 的定时器，但执行函数 `callback()` 里面需要 `2秒`。

#### A. 如果是互斥组 (MutuallyExclusive)：
1. `0s`: 第一次触发，开始执行。
2. `1s`: 第二次触发时间到了。**但是**：第一次还没跑完，第二次被丢进等待队列。
3. `2s`: 第一次跑完。
4. `2s`: 第二次才开始跑。
> **结果**：任务是串行的，永远不会有重叠。

#### B. 如果是可重入组 (Reentrant)：
1. `0s`: 第一次触发，线程 A 开始跑。
2. `1s`: 第二次触发时间到了。**直接重入**：Executor 派线程 B 立刻开始执行 `callback()`。
3. `1~2s` 之间：**两个线程正在同时运行同一个函数！**
> **这就是“重入”**：前一个还没出去，后一个就进来了。

---

## 4. 怎么通俗地理解？

你可以把回调用组看作 **“权限控制”**：

### 互斥组 (MutuallyExclusive) = **“独占锁”**
它像是一个狭小的单行道，一次只能走一辆车。不管你是奥迪还是宝马，只要前面有车，你就得等。

### 可重入组 (Reentrant) = **“多车道高速公路”**
它不是在管“谁在跑”，而是在管“路够不够宽”。只要 Executor（执行器）还有空余的线程，大家就可以并排跑。

---

## 5. 什么时候必须用可重入组？

最常见的场景是：**回调函数内部有死循环或很长的等待。**

**经典坑：Action 节点中的反馈**
如果你在 Action 的执行回调里，需要通过一个订阅者 (`Subscriber`) 获取信息，而这个订阅者和 Action 执行函数在同一个互斥组里：
1. Action 开始跑，占住了组。
2. 你在里面 `while` 等待订阅者消息。
3. 订阅者消息到了，想跑回调，但因为是互斥组，被卡住了。
4. **死锁发生**：你在等消息，消息在等你释放组。

**解决方案**：将它们放入 **Reentrant** 组。

---

## ⚠️ 终极警告：可重入 = 风险

当你把一个组设为 `Reentrant` 时，你就进入了**“多线程丛林”**。

你必须问自己：
1. **我有全局变量吗？** (如果没有 `std::mutex` 保护，程序会崩溃)
2. **我有共享资源吗？** (如文件写入、串行接口)
3. **我的逻辑支持并发吗？** (两个线程同时写一个变量会导致“竞态条件”)

### 总结建议
- **默认优先用 `MutuallyExclusive`**：因为它安全、简单。
- **除非发生死锁或必须极高并发**：才考虑 `Reentrant`。
- **如果用了 `Reentrant`**：请务必加上 `std::lock_guard<std::mutex>` 保护你的敏感变量！
